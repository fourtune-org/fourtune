import path from "node:path"
import {getBuildPath, getObjectsPath} from "../../getPath.mjs"

function checkFrozen(
	fourtune_session, op
) {
	if (fourtune_session.is_frozen) {
		throw new Error(
			`Cannot do operation "${op}" because session is frozen.`
		)
	}
}

export function createPublicInterfaceObject(
	fourtune_session
) {
	return {
		// can be used by user
		user_data: {},

		getProjectRoot() {
			return fourtune_session.project.root
		},

		getProjectConfig() {
			return fourtune_session.project.config
		},

		getProjectPackageJSON() {
			return fourtune_session.project.packageJSON
		},

		getRealmOptions() {
			const {realm} = fourtune_session.project.config

			if ("options" in realm) {
				return realm.options
			}

			return {}
		},

		// provide new .emit API early
		emit: {
			warning(id, message) {
				process.stderr.write(`$ fourtune [warning] ${message}\n`)
			},

			error(id, message) {
				process.stderr.write(`$ fourtune [error] ${message}\n`)
			}
		},

		emitWarning(id, meta) {
			process.stderr.write(
				`[warning] ${id} ${JSON.stringify(meta)}\n`
			)
		},

		emitError(id, meta) {
			process.stderr.write(
				`[error] ${id} ${JSON.stringify(meta)}\n`
			)
		},

		getDependency(dependency_name) {
			const map = fourtune_session.realm.loaded_dependencies

			if (!map.has(dependency_name)) {
				throw new Error(`No such dependency '${dependency_name}'.`)
			}

			return map.get(dependency_name).dependency
		},

		input: {
			getSourceFiles() {
				return fourtune_session.input.source_files
			},

			getFilteredSourceFiles() {
				return fourtune_session.input.source_files_filtered
			},

			getAssetFiles() {
				return fourtune_session.input.assets
			}
		},

		autogenerate: {
			addFourtuneFile(file_path, generator, generator_args = []) {
				checkFrozen(fourtune_session, "autogenerate.addFourtuneFile")

				fourtune_session.files_to_autogenerate.push({
					type: "fourtune",
					file_path: path.join("fourtune", path.normalize(file_path)),
					generator,
					generator_args
				})
			},

			//
			// synthetic files are a special kind of autogenerated file
			// that are generated (written to disk) before any of the
			// other autogenerated files are produced
			//
			addSyntheticFile(
				category,
				file_path,
				generator,
				generator_args = []
			) {
				if (!(["user", "async.sync"].includes(category))) {
					throw new Error(`Invalid category "${category}".`)
				}

				checkFrozen(fourtune_session, "autogenerate.addSyntheticFile")

				fourtune_session.files_to_autogenerate.push({
					type: `synthetic:${category}`,
					file_path: path.join(
						"synthetic",
						category,
						path.normalize(file_path)
					),
					generator,
					generator_args
				})
			}
		},

		objects: {
			addObject(file_path, generator, generator_args) {
				checkFrozen(fourtune_session, "objects.addObject")

				fourtune_session.objects_to_generate.push({
					file_path: path.normalize(file_path),
					generator,
					generator_args
				})
			}
		},

		products: {
			addProduct(
				product_name
			) {
				checkFrozen(fourtune_session, "products.addProduct")

				const product_ref = {
					product_name,
					distributables: []
				}

				fourtune_session.products_to_generate.push(product_ref)

				const product = {
					addDistributable(
						name, file_name, generator, generator_args = []
					) {
						product_ref.distributables.push({
							name,
							file_name,
							generator,
							generator_args
						})

						return product
					}
				}

				return product
			}
		},

		paths: {
			getBuildPath(...parts) {
				return getBuildPath("", ...parts)
			},

			getBuildPathFromProjectRoot(...parts) {
				return getBuildPath(fourtune_session.project.root, ...parts)
			},

			getObjectsPath(...parts) {
				return getObjectsPath("", ...parts)
			},

			getObjectsPathFromProjectRoot(...parts) {
				return getObjectsPath(fourtune_session.project.root, ...parts)
			}
		}
	}
}
